// Generated by CoffeeScript 1.10.0
var EventEmitter, Promise,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

EventEmitter = require('ui-js/core/event-emitter');

module.exports = Promise = (function(superClass) {
  extend(Promise, superClass);

  Promise.prototype.PENDING = 'pending';

  Promise.prototype.RESOLVED = 'resolved';

  Promise.prototype.REJECTED = 'rejected';

  Promise.prototype.ABORTED = 'aborted';

  function Promise(resolver) {
    this.progress = bind(this.progress, this);
    this.abort = bind(this.abort, this);
    this.reject = bind(this.reject, this);
    this.resolve = bind(this.resolve, this);
    var error, error1;
    if (!(this instanceof Promise)) {
      return new Promise(resolver);
    }
    Promise.__super__.constructor.apply(this, arguments);
    this.status = this.PENDING;
    this.value = void 0;
    this.queue = [];
    this.catched = false;
    this.completed = 0;
    this.done = false;
    this.aborted = false;
    this.description = '';
    try {
      if (resolver != null) {
        resolver.call(this, this.resolve, this.reject, this.progress);
      }
    } catch (error1) {
      error = error1;
      this.reject(error);
    }
    return;
  }

  Promise.prototype.resolve = function(value) {
    if (this.status !== this.PENDING) {
      return;
    }
    this.value = value;
    this.completed = 1;
    this.done = true;
    this.status = this.RESOLVED;
    this.run();
    this.emit('resolve', this.value);
    this.emit('done', this.value);
  };

  Promise.prototype.reject = function(value) {
    if (this.status !== this.PENDING) {
      return;
    }
    this.value = value;
    this.completed = 1;
    this.done = true;
    this.status = this.REJECTED;
    this.run();
    this.emit('reject', this.value);
    this.emit('done', this.value);
  };

  Promise.prototype.abort = function() {
    if (this.aborted) {
      return;
    }
    this.status = this.ABORTED;
    this.queue = [];
    this.aborted = true;
    this.emit('abort');
  };

  Promise.prototype.progress = function(completed, description1) {
    this.description = description1 != null ? description1 : '';
    this.completed = Math.max(Math.min(completed, 1), 0);
    return this.emit('progress', this.completed, this.description);
  };

  Promise.prototype.run = function() {
    var handlers, ref;
    if (this.status === this.PENDING) {
      return;
    }
    while (handlers = this.queue.shift()) {
      switch (this.status) {
        case this.RESOLVED:
          if ((ref = handlers.onResolve) != null) {
            ref.call(this, this.value);
          }
          break;
        case this.REJECTED:
          if (handlers.onReject) {
            handlers.onReject.call(this, this.value);
            this.catched = true;
          }
      }
    }
    if (this.status === this.REJECTED && !this.catched) {
      console.error('Promise error', this.value);
      throw this.value;
    }
  };

  Promise.prototype.then = function(onResolve, onReject, onProgress) {
    var handler, promise;
    promise = new Promise();
    if (onProgress) {
      promise.on('progress', onProgress);
    }
    promise.on('abort', this.abort);
    this.on('progress', promise.progress);
    handler = (function(_this) {
      return function(value) {
        var error, error1, func;
        try {
          func = _this.status === _this.RESOLVED ? onResolve : onReject;
          if (func) {
            value = func.call(_this, value);
          } else if (_this.status === _this.REJECTED) {
            promise.reject(value);
          }
          if (Promise.thenable(value)) {
            value.then(promise.resolve, promise.reject);
            return value.on('progress', promise.progress);
          } else {
            return promise.resolve(value);
          }
        } catch (error1) {
          error = error1;
          return promise.reject(error);
        }
      };
    })(this);
    this.queue.push({
      onResolve: handler,
      onReject: handler
    });
    this.run();
    return promise;
  };

  Promise.prototype["catch"] = function(onReject) {
    return this.then(null, onReject);
  };

  Promise.prototype["finally"] = function(handler) {
    return this.on('done', handler);
  };

  Promise.thenable = function(item) {
    return typeof (item != null ? item.then : void 0) === 'function';
  };

  Promise.resolve = function(value) {
    var promise;
    promise = new Promise;
    promise.resolve(value);
    return promise;
  };

  Promise.reject = function(value) {
    var promise;
    promise = new Promise;
    promise.reject(value);
    return promise;
  };

  Promise.all = function(promises, description) {
    var all, resolvedCnt, values;
    if (description == null) {
      description = '';
    }
    promises = promises.slice();
    all = new Promise;
    values = [];
    resolvedCnt = 0;
    promises.forEach(function(promise, index) {
      promise.then(function(value) {
        values[index] = value;
        if (++resolvedCnt === promises.length) {
          all.resolve(values);
        }
      }, all.reject);
      return promise.on('progress', (function(_this) {
        return function(completed) {
          var allCompleted, totalCompleted;
          allCompleted = 0;
          promises.forEach(function(promise) {
            return allCompleted += promise.completed;
          });
          totalCompleted = allCompleted / promises.length;
          all.progress(totalCompleted, '');
        };
      })(this));
    });
    return all;
  };

  return Promise;

})(EventEmitter);

//# sourceMappingURL=promise.js.map
