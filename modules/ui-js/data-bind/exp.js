// Generated by CoffeeScript 1.10.0
var ALIASES, Exp, KEYWORDS, ParseError, PathAccessor, PathStructure, PipeStructure, Structure, Token, TokenList, VAR_CONTEXT, VAR_HELPERS, VAR_REF, VAR_SCOPE, VAR_VALUE, createExp, createGetter, createSetter, createStringExp,
  slice = [].slice,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

VAR_REF = '$$ref';

VAR_CONTEXT = '$$context';

VAR_VALUE = '$$val';

VAR_SCOPE = '$$scope';

VAR_HELPERS = '$$helpers';

ALIASES = {
  'and': '&&',
  'or': '||',
  'then': '?',
  'else': ':',
  'is': '==',
  'isnt': '!==',
  'not': '!',
  'yes': 'true',
  'on': 'true',
  'no': 'false',
  'off': 'false',
  'undefined': 'void 0',
  'typeof': 'typeof ',
  'instanceof': 'instanceof ',
  '@': 'this',
  '#': 'scope'
};

KEYWORDS = {
  "null": true,
  "var": true,
  "void": true,
  "typeof": true,
  "instanceof": true,
  undefined: true,
  "true": true,
  "false": true
};

module.exports = Exp = (function() {
  Exp.cache = {};

  Exp.pipes = {};

  function Exp(code) {
    var exp;
    if (!code) {
      throw Error('exp is empty');
    }
    if (typeof code === 'function') {
      return code;
    }
    if (Exp.cache[code]) {
      return Exp.cache[code];
    }
    if (Exp.test(code)) {
      exp = createStringExp(code);
    } else {
      exp = createExp(code);
    }
    Exp.cache[code] = exp;
    return exp;
  }

  Exp.addPipe = function(name, pipe) {
    this.pipes[name] = pipe;
  };

  Exp.pipe = function() {
    var args, name, pipe;
    name = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    pipe = this.pipes[name];
    if (!pipe) {
      throw Error("Pipe '" + name + "' is not defined");
    }
    return pipe.apply(null, args);
  };

  Exp.test = function(code) {
    return /\{\{.*}}/.test(code);
  };

  Exp.parts = function(code) {
    return code.split(/\{\{|}}/);
  };

  Exp.split = function(code) {
    return this.parts(code).map(function(part, index) {
      if (index % 2) {
        return "{{" + part + "}}";
      } else {
        return part;
      }
    });
  };

  Exp.getValue = function(obj, exp) {
    exp = new Exp(exp);
    return exp(obj);
  };

  Exp.setValue = function(obj, exp, value) {
    exp = new Exp(exp);
    if (typeof exp.set === "function") {
      exp.set(obj, value);
    }
    return value;
  };

  return Exp;

})();

createExp = function(code) {
  var error, exp, tokens;
  tokens = new TokenList(code);
  exp = createGetter(tokens.compile());
  try {
    exp.set = createSetter(tokens.compile(true));
  } catch (error) {
    exp.set = null;
  }
  exp.paths = tokens.getPaths();
  exp.isStatic = tokens.isStatic();
  exp.isExp = true;
  exp.isStringExp = false;
  return exp;
};

createGetter = function(code) {
  var args, body, getter;
  args = VAR_CONTEXT + "," + VAR_SCOPE + "," + VAR_HELPERS;
  body = "var " + VAR_REF + ";if(!" + VAR_SCOPE + ")" + VAR_SCOPE + "={};return " + code;
  getter = new Function(args, body);
  return function(context, scope) {
    return getter(context, scope, Exp);
  };
};

createSetter = function(code) {
  var args, body, error, setter;
  try {
    args = VAR_CONTEXT + "," + VAR_VALUE + "," + VAR_SCOPE + "," + VAR_HELPERS;
    body = "var " + VAR_REF + ";if(!" + VAR_SCOPE + ")" + VAR_SCOPE + "={};return " + code + "=" + VAR_VALUE;
    setter = new Function(args, body);
    return function(context, value, scope) {
      return setter(context, value, scope, Exp);
    };
  } catch (error) {
    return null;
  }
};

createStringExp = function(code) {
  var compiledPart, exp, i, index, isStatic, len, part, partPaths, parts, partsString, paths, result, tokens;
  parts = Exp.parts(code);
  partsString = [];
  isStatic = true;
  paths = [];
  for (index = i = 0, len = parts.length; i < len; index = ++i) {
    part = parts[index];
    if (part) {
      if (index % 2) {
        tokens = new TokenList(part);
        partPaths = tokens.getPaths();
        paths.push.apply(paths, partPaths);
        if (!tokens.isStatic()) {
          isStatic = false;
        }
        compiledPart = tokens.compile();
        partsString.push("(" + VAR_REF + "=(" + compiledPart + ")," + VAR_REF + "!=null?" + VAR_REF + "+'':'')");
      } else {
        part = part.replace(/'/img, "\\'");
        part = "'" + part + "'";
        tokens = new TokenList(part);
        compiledPart = tokens.compile();
        partsString.push(compiledPart);
      }
    }
  }
  result = partsString.join('+');
  exp = createGetter(result);
  exp.set = null;
  exp.isStatic = isStatic;
  exp.isExp = true;
  exp.paths = paths;
  exp.isStringExp = true;
  return exp;
};

ParseError = (function(superClass) {
  extend(ParseError, superClass);

  function ParseError(message, type) {
    if (!(this instanceof ParseError)) {
      return new ParseError(message, type);
    }
    this.message = message;
    this.name = 'ParseError';
    if (type != null) {
      this.name += " " + type;
    }
  }

  ParseError.prototype.toString = function() {
    return this.name + ": " + this.message;
  };

  return ParseError;

})(Error);

Token = (function() {
  Token.regExp = /(("|')(?:\\\2|[\s\S])*?\2)|(?:([$\w]+)\s*:)|(\d+)|([$\w]+)|(\+\+|--)|(\S)/img;

  function Token(matches) {
    var isCrement, isKey, isNumber, isString, isSymbol, isWord;
    this.value = matches[0];
    isString = matches[2];
    isKey = matches[3];
    isNumber = matches[4];
    isWord = matches[5];
    isCrement = matches[6];
    isSymbol = matches[7];
    this.alias = ALIASES[this.value] || null;
    this.isKey = !!isKey;
    this.isWord = !!isWord || this.isKey;
    this.isCrement = !!isCrement;
    this.isString = !!isString;
    this.isNumber = !!isNumber;
    this.isLiteral = !!(this.isString || this.isNumber);
    this.isSymbol = !!isSymbol;
    this.isVar = (this.value === VAR_REF) || (this.value === VAR_CONTEXT) || (this.value === VAR_VALUE);
    this.isKeyword = !!(KEYWORDS[this.value] || ALIASES[this.value]);
    this.isProp = !!((isWord && !this.isKeyword && !this.isKey && !this.isVar) || (this.value === '@') || (this.value === '#'));
    this.isOperator = !!(isSymbol || isCrement || this.isKeyword) && !this.isProp;
    this.isBracketStart = this.match('[', '(', '{');
    return;
  }

  Token.prototype.match = function() {
    var i, len, value, values;
    values = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    for (i = 0, len = values.length; i < len; i++) {
      value = values[i];
      if (this.value === value) {
        return true;
      }
    }
    return false;
  };

  Token.prototype.toString = function() {
    return this.value;
  };

  Token.prototype.compile = function() {
    if (this.isString) {
      return this.value.replace(/\n/img, '\\n');
    }
    return this.alias || this.value;
  };

  return Token;

})();

TokenList = (function(superClass) {
  extend(TokenList, superClass);

  function TokenList(code1) {
    this.code = code1 != null ? code1 : null;
    this.structures = null;
    if (this.code != null) {
      this.parseCode(this.code);
    }
    return;
  }

  TokenList.prototype.getPaths = function() {
    var i, len, paths, ref1, structure, structurePaths;
    paths = [];
    ref1 = this.getStructures();
    for (i = 0, len = ref1.length; i < len; i++) {
      structure = ref1[i];
      structurePaths = structure.getPaths();
      paths.push.apply(paths, structurePaths);
    }
    return paths;
  };

  TokenList.prototype.parseCode = function(code) {
    code.replace(Token.regExp, (function(_this) {
      return function() {
        return _this.push(new Token(arguments));
      };
    })(this));
  };

  TokenList.prototype.indexOfValue = function(value, index) {
    var token;
    if (index == null) {
      index = 0;
    }
    while (index < this.length) {
      token = this[index];
      if (token.value === value) {
        return index;
      }
      index++;
    }
    return -1;
  };

  TokenList.prototype.sequence = function(index, handler) {
    var setIndex, token;
    if (index == null) {
      index = 0;
    }
    setIndex = function(newIndex) {
      if (newIndex < index) {
        throw ParseError('sequence setIndex set newIndex < index');
      }
      return index = newIndex;
    };
    while (index < this.length) {
      token = this[index];
      if (handler(token, index, setIndex) === false) {
        break;
      }
      index++;
    }
    return index;
  };

  TokenList.prototype.slice = function(start, end) {
    var tokens;
    tokens = new TokenList();
    tokens.push.apply(tokens, TokenList.__super__.slice.call(this, start, end));
    tokens.code = tokens.toString();
    return tokens;
  };

  TokenList.prototype.prev = function(index) {
    return this[index - 1];
  };

  TokenList.prototype.next = function(index) {
    return this[index + 1];
  };

  TokenList.prototype.findStringEnd = function(startToken, index) {
    var endIndex;
    endIndex = this.indexOfValue(startToken.value, index + 1);
    if (endIndex === -1) {
      throw ParseError(this.code, 'string not closed');
    }
    return endIndex;
  };

  TokenList.prototype.findBracketEnd = function(startToken, index) {
    var close, nesting, open, token;
    open = startToken.value;
    if (open === '[') {
      close = ']';
    }
    if (open === '(') {
      close = ')';
    }
    if (open === '{') {
      close = '}';
    }
    nesting = 0;
    while (index < this.length) {
      token = this[index];
      if (token.isQuote) {
        index = this.findStringEnd(token, index);
        token = this[index];
      }
      if (token.value === open) {
        nesting++;
      }
      if (token.value === close) {
        nesting--;
      }
      if (nesting === 0) {
        return index;
      }
      index++;
    }
    throw ParseError(this.code, 'bracket not closed');
  };

  TokenList.prototype.findPathEnd = function(index) {
    return this.sequence(index, (function(_this) {
      return function(token, index, setIndex) {
        if (token.isProp) {
          return true;
        }
        if (token.value === '.') {
          return true;
        }
        if (token.match('(', '[')) {
          setIndex(_this.findBracketEnd(token, index));
          return true;
        }
        return false;
      };
    })(this));
  };

  TokenList.prototype.findOtherEnd = function(index) {
    return this.sequence(index, (function(_this) {
      return function(token) {
        if (token.isProp) {
          return false;
        }
        if (token.value === '|') {
          return false;
        }
      };
    })(this));
  };

  TokenList.prototype.findPipeEnd = function(index) {
    return this.sequence(index + 1, (function(_this) {
      return function(token, index, setIndex) {
        var endIndex;
        if (token.isProp) {
          return;
        }
        if (token.value === '(') {
          endIndex = setIndex(_this.findBracketEnd(token, index));
          setIndex(endIndex + 1);
        }
        return false;
      };
    })(this));
  };

  TokenList.prototype.getStructures = function() {
    var structures;
    if (this.structures) {
      return this.structures;
    }
    structures = [];
    this.sequence(0, (function(_this) {
      return function(token, index, setIndex) {
        var endIndex;
        if (token.isProp) {
          endIndex = _this.findPathEnd(index);
          structures.push(new PathStructure(_this.slice(index, endIndex)));
          setIndex(endIndex - 1);
          return;
        }
        if (token.value === '|') {
          endIndex = _this.findPipeEnd(index);
          structures.push(new PipeStructure(_this.slice(index + 1, endIndex)));
          setIndex(endIndex - 1);
          return;
        }
        endIndex = _this.findOtherEnd(index);
        structures.push(new Structure(_this.slice(index, endIndex)));
        setIndex(endIndex - 1);
      };
    })(this));
    this.structures = structures;
    return structures;
  };

  TokenList.prototype.toString = function(separator) {
    var values;
    if (separator == null) {
      separator = '';
    }
    values = this.map(function(token) {
      return token.toString();
    });
    return values.join(separator);
  };

  TokenList.prototype.compile = function(setterMode) {
    var compiledCode, compiledStructure, forceSetter, i, index, lastStructure, len, nextStructure, structure, structures;
    if (setterMode == null) {
      setterMode = false;
    }
    structures = this.getStructures();
    compiledCode = '';
    if (setterMode) {
      if (structures.length > 1) {
        throw Error('Cant compile to setter');
      }
      lastStructure = structures[structures.length - 1];
      if (lastStructure.type !== 'path') {
        throw Error('Cant compile to setter');
      }
    }
    for (index = i = 0, len = structures.length; i < len; index = ++i) {
      structure = structures[index];
      forceSetter = false;
      if (structure.type === 'pipe') {
        continue;
      }
      if (structure.type === 'path') {
        nextStructure = structures[index + 1];
        if (nextStructure) {
          forceSetter = nextStructure.tokens.some(function(token) {
            return token.isCrement || token.value === '=';
          });
        }
      }
      compiledStructure = structure.compile(setterMode || forceSetter);
      if (structure.type === 'path') {
        nextStructure = structures[index + 1];
        if (nextStructure instanceof PipeStructure) {
          compiledStructure = nextStructure.compile(compiledStructure);
        }
      }
      compiledCode += compiledStructure;
    }
    return compiledCode;
  };

  TokenList.prototype.isStatic = function() {
    var i, len, structure, structures;
    structures = this.getStructures();
    for (i = 0, len = structures.length; i < len; i++) {
      structure = structures[i];
      if (structure.type === 'path') {
        return false;
      }
      if (structure.type === 'pipe') {
        return false;
      }
    }
    return true;
  };

  TokenList.prototype.search = function(value) {
    var i, index, len, token;
    for (index = i = 0, len = this.length; i < len; index = ++i) {
      token = this[index];
      if (token.value === value) {
        return index;
      }
    }
    return -1;
  };

  return TokenList;

})(Array);

Structure = (function() {
  function Structure(tokens1, type1) {
    this.tokens = tokens1;
    this.type = type1 != null ? type1 : 'other';
    return;
  }

  Structure.prototype.toString = function() {
    return this.tokens.toString();
  };

  Structure.prototype.compile = function() {
    var i, len, ref1, string, token;
    string = '';
    ref1 = this.tokens;
    for (i = 0, len = ref1.length; i < len; i++) {
      token = ref1[i];
      string += token.compile();
    }
    return string;
  };

  Structure.prototype.getPaths = function() {
    return [];
  };

  return Structure;

})();

PipeStructure = (function(superClass) {
  extend(PipeStructure, superClass);

  function PipeStructure(tokens) {
    PipeStructure.__super__.constructor.call(this, tokens, 'pipe');
    this.name = '';
    this.args = null;
    this.parse(tokens);
    return;
  }

  PipeStructure.prototype.parse = function(tokens) {
    this.name = tokens[0].value;
    if (tokens.length > 1) {
      this.args = tokens.slice(2, -1);
    }
  };

  PipeStructure.prototype.getPaths = function() {
    var ref1;
    return ((ref1 = this.args) != null ? ref1.getPaths() : void 0) || [];
  };

  PipeStructure.prototype.compile = function(base) {
    if (this.args) {
      return VAR_HELPERS + ".pipe('" + this.name + "',(" + base + ")," + (this.args.compile()) + ")";
    } else {
      return VAR_HELPERS + ".pipe('" + this.name + "',(" + base + "))";
    }
  };

  return PipeStructure;

})(Structure);

PathStructure = (function(superClass) {
  extend(PathStructure, superClass);

  function PathStructure(tokens) {
    PathStructure.__super__.constructor.call(this, tokens, 'path');
    this.accessors = this.parse(tokens);
    return;
  }

  PathStructure.prototype.getProps = function() {
    var accessor, i, len, prop, props, ref1;
    props = [];
    ref1 = this.accessors;
    for (i = 0, len = ref1.length; i < len; i++) {
      accessor = ref1[i];
      if (accessor.type === 'prop') {
        prop = accessor.name.toString();
        props.push(prop);
      }
    }
    return props;
  };

  PathStructure.prototype.getPaths = function() {
    return [this.accessors.slice()];
  };

  PathStructure.prototype.parse = function(tokens) {
    var accessors;
    accessors = [];
    tokens.sequence(0, function(token, index, setIndex) {
      var endIndex, exp, nextToken;
      if (token.isProp) {
        nextToken = tokens.next(index);
        if (!nextToken) {
          return accessors.push(new PathAccessor(token, 'prop'));
        } else {
          switch (nextToken.value) {
            case '.':
              return accessors.push(new PathAccessor(token, 'prop'));
            case '(':
              endIndex = tokens.findBracketEnd(nextToken, index + 1);
              exp = tokens.slice(index + 2, endIndex);
              accessors.push(new PathAccessor(token, 'call', exp));
              return setIndex(endIndex);
            default:
              return accessors.push(new PathAccessor(token, 'prop'));
          }
        }
      } else if (token.isOperator) {
        switch (token.value) {
          case '[':
            endIndex = tokens.findBracketEnd(token, index);
            exp = tokens.slice(index + 1, endIndex);
            accessors.push(new PathAccessor(null, 'exp', exp));
            return setIndex(endIndex);
          case '(':
            endIndex = tokens.findBracketEnd(token, index);
            exp = tokens.slice(index + 1, endIndex);
            accessors.push(new PathAccessor(null, 'call', exp));
            return setIndex(endIndex);
        }
      }
    });
    return accessors;
  };

  PathStructure.prototype.compile = function(setterMode) {
    var accessor, firstProp, i, index, len, path, ref1;
    if (setterMode == null) {
      setterMode = false;
    }
    firstProp = this.accessors[0].name.compile();
    path = "(" + VAR_SCOPE + "." + firstProp + "!=null?" + VAR_SCOPE + ":" + VAR_CONTEXT + ")";
    ref1 = this.accessors;
    for (index = i = 0, len = ref1.length; i < len; index = ++i) {
      accessor = ref1[index];
      if (index === 0 && accessor.type !== 'call') {
        path += accessor.compile();
        continue;
      }
      if (setterMode && index === this.accessors.length - 1) {
        path = accessor.setterEscape(path);
        continue;
      }
      path = accessor.escape(path);
    }
    return path;
  };

  return PathStructure;

})(Structure);

PathAccessor = (function() {
  function PathAccessor(name1, type1, exp1) {
    this.name = name1;
    this.type = type1;
    this.exp = exp1 != null ? exp1 : null;
    return;
  }

  PathAccessor.prototype.toString = function() {
    switch (this.type) {
      case 'prop':
        return "." + this.name;
      case 'exp':
        return "[" + this.exp + "]";
      case 'call':
        if (this.name) {
          return "." + this.name + "(" + this.exp + ")";
        } else {
          return "(" + this.exp + ")";
        }
    }
  };

  PathAccessor.prototype.compile = function() {
    switch (this.type) {
      case 'prop':
        return "." + (this.name.compile());
      case 'exp':
        return "[" + (this.exp.compile()) + "]";
      case 'call':
        if (this.name) {
          return "." + (this.name.compile()) + "(" + (this.exp.compile()) + ")";
        } else {
          return "(" + (this.exp.compile()) + ")";
        }
    }
  };

  PathAccessor.prototype.escape = function(base) {
    var exp, ref;
    ref = VAR_REF;
    switch (this.type) {
      case 'prop':
        return "(" + ref + "=" + base + "," + ref + "!=null?" + ref + "." + this.name + ":void 0)";
      case 'exp':
        return "(" + ref + "=" + base + "," + ref + "!=null?" + ref + "[" + (this.exp.compile()) + "]:void 0)";
      case 'call':
        exp = this.exp.compile();
        if (this.name) {
          return "(" + ref + "=" + base + "," + ref + "!=null&&typeof " + ref + "." + this.name + "==='function'?" + ref + "." + this.name + "(" + exp + "):void 0)";
        } else {
          return "(" + ref + "=" + base + ",typeof " + ref + "==='function'?" + ref + "(" + exp + "):void 0)";
        }
    }
  };

  PathAccessor.prototype.setterEscape = function(base) {
    return "(" + base + " || {})" + (this.toString());
  };

  return PathAccessor;

})();

//# sourceMappingURL=exp.js.map
