// Generated by CoffeeScript 1.10.0
var DOM, For, Iteration,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  slice = [].slice;

DOM = require('ui-js/dom');

module.exports = For = (function() {
  var regExp;

  regExp = /^\s*(?:([\w$]+)(?:,\s*([\w$]+))?\s+in\s+)?(.+?)\s*$/;

  For.attribute = 'for';

  For.priority = 1000;

  For.terminal = true;

  For.compile = function(template, tree) {
    var comment, exp, indexName, itemName, match, subTree;
    exp = template.attr('*for');
    template.removeAttr('*for');
    comment = DOM.createComment(" *for " + exp + " ");
    tree.replace(comment);
    match = exp.match(regExp);
    itemName = match[1];
    indexName = match[2];
    exp = match[3];
    subTree = tree.create(template);
    return [subTree, itemName, indexName, exp];
  };

  function For(label1, component, locals1, subThree, itemName1, indexName1, exp) {
    this.label = label1;
    this.component = component;
    this.locals = locals1;
    this.subThree = subThree;
    this.itemName = itemName1;
    this.indexName = indexName1;
    this.renderSplices = bind(this.renderSplices, this);
    this.changeArray = bind(this.changeArray, this);
    this.array = [];
    this.iterations = [];
    this.observer = null;
    ui.watch(this.component, exp, this.changeArray, this.locals);
    return;
  }

  For.prototype.destructor = function() {
    var ref;
    if ((ref = this.observer) != null) {
      ref.destroy();
    }
  };

  For.prototype.changeArray = function(newArray) {
    var i, j, ref, results, results1, splices;
    if (newArray == null) {
      newArray = [];
    }
    if (typeof newArray === 'number') {
      if (newArray <= 0) {
        newArray = [];
      } else {
        newArray = (function() {
          results = [];
          for (var i = 0; 0 <= newArray ? i < newArray : i > newArray; 0 <= newArray ? i++ : i--){ results.push(i); }
          return results;
        }).apply(this);
      }
    } else if (typeof newArray === 'string' && !isNaN(newArray)) {
      newArray = +newArray;
      newArray = (function() {
        results1 = [];
        for (var j = 0; 0 <= newArray ? j < newArray : j > newArray; 0 <= newArray ? j++ : j--){ results1.push(j); }
        return results1;
      }).apply(this);
    } else if (!(newArray instanceof Array)) {
      throw Error('invalid *for array');
    }
    splices = ui.diff(newArray, this.array);
    this.array = newArray;
    if (splices.length) {
      this.renderSplices(splices);
    }
    if ((ref = this.observer) != null) {
      ref.destroy();
    }
    this.observer = ui.watchArray(this.array, this.renderSplices);
  };

  For.prototype.renderSplices = function(splices) {
    var i, len, splice;
    for (i = 0, len = splices.length; i < len; i++) {
      splice = splices[i];
      this.spliceIterations(splice);
    }
    this.updateIndexes();
  };

  For.prototype.updateIndexes = function() {
    var i, index, iteration, len, ref;
    if (!this.indexName) {
      return;
    }
    ref = this.iterations;
    for (index = i = 0, len = ref.length; i < len; index = ++i) {
      iteration = ref[index];
      iteration.locals[this.indexName] = index;
    }
  };

  For.prototype.spliceIterations = function(splice) {
    var addedCnt, cnt, content, i, index, iteration, j, len, len1, newIterations, ref, removed, removedCnt, startIndex;
    startIndex = splice.index;
    addedCnt = splice.addedCount;
    removedCnt = splice.removed.length;
    newIterations = [];
    content = [];
    cnt = 0;
    while (cnt < addedCnt) {
      index = startIndex + cnt;
      iteration = new Iteration(this.subThree, this.component, this.locals);
      iteration.locals[this.itemName] = this.array[index];
      newIterations.push(iteration);
      content.push(iteration.node);
      content.push(iteration.endLabel);
      cnt++;
    }
    this.insertIterationsContent(startIndex, content);
    removed = (ref = this.iterations).splice.apply(ref, [startIndex, removedCnt].concat(slice.call(newIterations)));
    for (i = 0, len = removed.length; i < len; i++) {
      iteration = removed[i];
      iteration.destroy();
    }
    for (j = 0, len1 = newIterations.length; j < len1; j++) {
      iteration = newIterations[j];
      iteration.init();
    }
  };

  For.prototype.insertIterationsContent = function(index, content) {
    var label;
    if (index === 0) {
      label = this.label;
    } else if (index > this.iterations.length - 1) {
      label = this.iterations[this.iterations.length - 1].endLabel;
    } else {
      label = this.iterations[index].endLabel;
    }
    label.after(content);
  };

  return For;

})();

Iteration = (function() {
  function Iteration(subThree, component, locals) {
    this.subThree = subThree;
    this.component = component;
    this.locals = Object.create(locals);
    this.node = this.subThree.template.clone();
    this.endLabel = DOM.createComment(' *for iteration ');
    return;
  }

  Iteration.prototype.init = function(item) {
    this.subThree.init(this.node, this.component, this.locals);
  };

  Iteration.prototype.destroy = function() {
    this.endLabel.destroy(true, true);
    this.node.destroy(true, true);
  };

  return Iteration;

})();

//# sourceMappingURL=for.js.map
