// Generated by CoffeeScript 1.10.0
var Selector,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

module.exports = Selector = (function() {
  var cache, regExp, subSelectorRegExp;

  regExp = /(?:(\s*>\s*)|^|\s+)(\S+)/img;

  subSelectorRegExp = /([\w-]+)|\.([\w-]+)|#([\w-]+)|\[([\w-]+)(?:(\^|\$|\*|~|\|)?=('|")(.*?)\6)?]/img;

  cache = {};

  function Selector(selectorText) {
    if (cache[selectorText]) {
      return cache[selectorText];
    }
    this.selectors = this.parseSelector(selectorText);
    cache[selectorText] = this;
    return;
  }

  Selector.prototype.parseSelector = function(selector) {
    var i, len, part, ref, selectors, subSelectors;
    selectors = [];
    ref = selector.trim().split(/\s*,\s*/);
    for (i = 0, len = ref.length; i < len; i++) {
      part = ref[i];
      subSelectors = [];
      part.replace(regExp, (function(_this) {
        return function(match, own, subSelector) {
          return subSelectors.push({
            own: !!own,
            selector: _this.parseSubSelector(subSelector)
          });
        };
      })(this));
      selectors.push(subSelectors);
    }
    return selectors;
  };

  Selector.prototype.parseSubSelector = function(subSelector) {
    var parsed;
    parsed = {
      tag: null,
      attrs: []
    };
    subSelector.replace(subSelectorRegExp, function(match, tag, className, id, attrName, attrMode, quote, attrValue) {
      var mode;
      if (tag === '*') {
        tag = null;
      }
      if (tag) {
        parsed.tag = tag;
      }
      if (className) {
        parsed.attrs.push({
          name: 'class',
          value: className,
          mode: 'word'
        });
      } else if (id) {
        parsed.attrs.push({
          name: 'id',
          value: id,
          mode: 'equals'
        });
      } else if (attrName) {
        if (attrValue != null) {
          mode = (function() {
            switch (attrMode) {
              case '^':
                return 'start';
              case '$':
                return 'end';
              case '*':
                return 'content';
              case '~':
                return 'word';
              case '|':
                return 'dash';
              default:
                return 'equals';
            }
          })();
        }
        parsed.attrs.push({
          name: attrName,
          value: attrValue,
          mode: mode
        });
      }
    });
    return parsed;
  };

  Selector.prototype.select = function(element) {
    var contextElement, contextElements, found, foundElements, i, j, k, l, len, len1, len2, len3, newContextElements, own, ref, selector, subSelector, subSelectors;
    found = [];
    ref = this.selectors;
    for (i = 0, len = ref.length; i < len; i++) {
      subSelectors = ref[i];
      if (!subSelectors.length) {
        continue;
      }
      contextElements = [element];
      for (j = 0, len1 = subSelectors.length; j < len1; j++) {
        subSelector = subSelectors[j];
        newContextElements = [];
        for (k = 0, len2 = contextElements.length; k < len2; k++) {
          contextElement = contextElements[k];
          own = subSelector.own;
          selector = subSelector.selector;
          foundElements = this.selectChildren(contextElement, selector, own);
          newContextElements.push.apply(newContextElements, foundElements);
        }
        contextElements = newContextElements;
        if (!contextElements.length) {
          break;
        }
      }
      for (l = 0, len3 = contextElements.length; l < len3; l++) {
        contextElement = contextElements[l];
        if (found.indexOf(contextElement) === -1) {
          found.push(contextElement);
        }
      }
    }
    return found;
  };

  Selector.prototype.selectChildren = function(element, subSelector, own) {
    var child, children, elements, i, len, subChildren;
    if (own == null) {
      own = false;
    }
    elements = [];
    children = element.children;
    if (children) {
      for (i = 0, len = children.length; i < len; i++) {
        child = children[i];
        if (this.matchElement(child, subSelector)) {
          elements.push(child);
        }
        if (!own) {
          subChildren = this.selectChildren(child, subSelector);
          elements.push.apply(elements, subChildren);
        }
      }
    }
    return elements;
  };

  Selector.prototype.matchElement = function(element, subSelector) {
    var attr, attrValue, i, index, len, name, ref, value, words;
    if (element.nodeType !== 'element') {
      return false;
    }
    if (subSelector.tag && element.tag !== subSelector.tag) {
      return false;
    }
    ref = subSelector.attrs;
    for (i = 0, len = ref.length; i < len; i++) {
      attr = ref[i];
      name = attr.name;
      if (!element.hasAttr(name)) {
        return false;
      }
      value = '' + attr.value;
      attrValue = '' + element.attrs.get(name);
      switch (attr.mode) {
        case 'equals':
          if (value !== attrValue) {
            return false;
          }
          break;
        case 'start':
          if (attrValue.indexOf(value) !== 0) {
            return false;
          }
          break;
        case 'end':
          index = attrValue.lastIndexOf(value);
          if (index === -1) {
            return false;
          }
          if (index + value.length !== attrValue.length) {
            return false;
          }
          break;
        case 'content':
          index = attrValue.indexOf(value);
          if (index === -1) {
            return false;
          }
          break;
        case 'word':
          words = attrValue.split(/\s+/img);
          if (indexOf.call(words, value) < 0) {
            return false;
          }
          break;
        case 'dash':
          words = attrValue.split(/-/img);
          if (words[0] !== value) {
            return false;
          }
      }
    }
    return true;
  };

  return Selector;

})();

//# sourceMappingURL=selector.js.map
