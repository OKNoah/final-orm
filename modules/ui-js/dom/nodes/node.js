// Generated by CoffeeScript 1.10.0
var EventEmitter, Node, NodeMutation,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

EventEmitter = require('ui-js/core/event-emitter');

NodeMutation = require('../mutations/node-mutation');

module.exports = Node = (function(superClass) {
  extend(Node, superClass);

  Node.lastId = 0;

  function Node() {
    Node.__super__.constructor.apply(this, arguments);
    this.nodeId = Node.lastId++;
    this.realNode = null;
    this.parent = null;
    this.children = [];
    this.observers = [];
    return;
  }

  Node.prototype.init = function(realNode) {
    this.realNode = realNode;
    this.emit('init', this.realNode);
  };

  Node.prototype.observe = function(observer) {
    this.observers.push(observer);
  };

  Node.prototype.createMutation = function() {
    return new NodeMutation(this);
  };

  Node.prototype.mutate = function(handler) {
    var i, len, mutation, observer, observers;
    observers = this.getObservers();
    for (i = 0, len = observers.length; i < len; i++) {
      observer = observers[i];
      mutation = observer.initMutation(this);
      if (typeof handler === "function") {
        handler(mutation);
      }
    }
  };

  Node.prototype.getObservers = function() {
    var context, observers;
    observers = [];
    context = this;
    while (context) {
      observers.push.apply(observers, context.observers);
      context = context.parent || context.host;
    }
    return observers;
  };

  Node.prototype.destroy = function(destroyChildren, needRemove) {
    var child, i, len, ref;
    if (destroyChildren == null) {
      destroyChildren = true;
    }
    if (needRemove == null) {
      needRemove = false;
    }
    this.removeAllEventHandlers();
    if (destroyChildren) {
      ref = this.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        child.destroy(true, false);
      }
    }
    if (needRemove) {
      this.remove();
    }
    this.emit('destroy');
  };

  Node.prototype.clone = function() {
    throw Error('Node clone is a pure virtual method');
  };

  Node.prototype.remove = function() {
    var ref;
    if ((ref = this.parent) != null) {
      ref.removeChild(this);
    }
  };

  Node.prototype.getIndex = function() {
    return this.parent.getChildIndex(this);
  };

  Node.prototype.append = function(node) {
    node.remove();
    node.parent = this;
    this.children.push(node);
    this.mutate(function(mutation) {
      return mutation.changeChildren();
    });
  };

  Node.prototype.appendTo = function(node) {
    node.append(this);
  };

  Node.prototype.prepend = function(node) {
    node.remove();
    node.parent = this;
    this.children.unshift(node);
    this.mutate(function(mutation) {
      return mutation.changeChildren();
    });
  };

  Node.prototype.prependTo = function(node) {
    node.append(this);
  };

  Node.prototype.insertBefore = function(relChild, node) {
    var index;
    node.remove();
    node.parent = this;
    index = relChild.getIndex();
    this.children.splice(index, 0, node);
    this.mutate(function(mutation) {
      return mutation.changeChildren();
    });
  };

  Node.prototype.before = function(node) {
    this.parent.insertBefore(this, node);
  };

  Node.prototype.insertAfter = function(relChild, node) {
    var arr, i, index, len, ref;
    if (node instanceof Array) {
      arr = node;
      index = relChild.getIndex();
      (ref = this.children).splice.apply(ref, [index + 1, 0].concat(slice.call(arr)));
      for (i = 0, len = arr.length; i < len; i++) {
        node = arr[i];
        node.remove();
        node.parent = this;
      }
    } else {
      node.remove();
      node.parent = this;
      index = relChild.getIndex();
      this.children.splice(index + 1, 0, node);
    }
    this.mutate(function(mutation) {
      return mutation.changeChildren();
    });
  };

  Node.prototype.after = function(node) {
    this.parent.insertAfter(this, node);
  };

  Node.prototype.replaceChild = function(child, newChild) {
    var index;
    index = child.getIndex();
    this.children[index] = newChild;
    child.parent = null;
    newChild.parent = this;
    this.mutate(function(mutation) {
      return mutation.changeChildren();
    });
  };

  Node.prototype.replace = function(newNode) {
    this.parent.replaceChild(this, newNode);
  };

  Node.prototype.empty = function() {
    var child, i, len, ref;
    ref = this.children.slice();
    for (i = 0, len = ref.length; i < len; i++) {
      child = ref[i];
      this.removeChild(child);
    }
  };

  Node.prototype.removeChild = function(child) {
    var index;
    index = child.getIndex();
    this.children.splice(index, 1);
    child.parent = null;
    this.mutate(function(mutation) {
      return mutation.changeChildren();
    });
  };

  Node.prototype.getChildIndex = function(node) {
    return this.children.indexOf(node);
  };

  Node.prototype.hasChild = function(node) {
    return node.parent === this;
  };

  return Node;

})(EventEmitter);

//# sourceMappingURL=node.js.map
